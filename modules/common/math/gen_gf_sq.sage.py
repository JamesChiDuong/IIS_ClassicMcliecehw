

# This file was *autogenerated* from the file /home/james/Documents/IIS/FPGA/Cryto/ClassicMceliehw_FPGA/test/ClassicMceliehw_FPGA/modules/common/math/gen_gf_sq.sage
from sage.all_cmdline import *   # import sage library

_sage_const_13 = Integer(13); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_16 = Integer(16)#
# Copyright (C) 2018
# Function: generate the module for finite field element squaring.
# Authors: Wen Wang <wen.wang.ww349@yale.edu>
#          Ruben Niederhagen <ruben@polycephaly.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import argparse

parser = argparse.ArgumentParser(description='Generate GF(m) multiplier module.',
                formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('-m','--gf', dest='gf', type=int, default=_sage_const_13 ,
          help='field 2^m')
args = parser.parse_args()


gf = args.gf

F = GF(_sage_const_2 )['x']; (x,) = F._first_ngens(1)
K = GF(_sage_const_2 **gf, modulus="first_lexicographic", names=('a',)); (a,) = K._first_ngens(1)
 
def set_red(f, g):
  diff = len(f) - g[_sage_const_0 ] - _sage_const_1 

  while diff >= _sage_const_0 :
    s = f[-_sage_const_1 ]

    for i in g:
      f[diff + i] = s.symmetric_difference(f[diff + i])

    while len(f[-_sage_const_1 ]) == _sage_const_0 :
      del f[-_sage_const_1 ]

    diff = len(f) - g[_sage_const_0 ] - _sage_const_1 

  return f

f = []

for i in range(gf*_sage_const_2 ):
  f.append(set([i]))

f_red = set_red(f, K.modulus().exponents()[::-_sage_const_1 ])



g_sq = []
for i in range(gf*_sage_const_2 ):
  g_sq.append([])

for i in range(gf):
  g_sq[i*_sage_const_2 ] = [i]

fin = []
for i in range(gf):
  fin.append([])

for i, l in enumerate(f_red):
  for j in l:
    fin[i] += g_sq[j]


# verify
for i in range(_sage_const_16 ):
  h = K.random_element()
  
  tmp = _sage_const_0 
  
  for i, t in enumerate(fin):
    for j in t:
      tmp += x**i * h.polynomial()[j]

  assert sage_eval(str(tmp), locals={'x':a}) == (h*h)


print("""module gf_sq (
  input            clk,
  input  [{0} : 0] din,
  output [{0} : 0] dout
);\n""".format(gf-_sage_const_1 ))

for i, l in enumerate(fin):
  print("  assign dout[{0}] = ".format(i) + " ^ ".join(["din[{0}]".format(j) for j in l]) + ";")

print("\nendmodule")


